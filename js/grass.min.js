function setCameraPosition(e,n,t,o){e.position.set(n,t,o),e.lookAt(new THREE.Vector3(0,0,0))}function onWindowResize(){let e=canvas.clientWidth,n=canvas.clientHeight;renderer.setPixelRatio(defaultPixelRatio),camera.aspect=e/n,renderer.setSize(e,n,!1),backgroundMaterial.uniforms.resolution.value=new THREE.Vector2(canvas.width,canvas.height),camera.updateProjectionMatrix()}function setQuaternion(e,n,t){let o=Math.sin(t/2),a=n.x*o,r=n.y*o,i=n.z*o,s=Math.cos(t/2);e.set(a,r,i,s)}function move(e){camera.getWorldDirection(viewDirection),length=Math.sqrt(viewDirection.x*viewDirection.x+viewDirection.z*viewDirection.z),viewDirection.x/=length,viewDirection.z/=length,pos.x+=e*speed*viewDirection.x,pos.y+=e*speed*viewDirection.z,groundShader&&(groundShader.uniforms.posX.value=pos.x,groundShader.uniforms.posZ.value=pos.y),grassMaterial.uniforms.posX.value=pos.x,grassMaterial.uniforms.posZ.value=pos.y}function draw(){thisFrame=Date.now();var e=(thisFrame-lastFrame)/200;time+=e,move(e),lastFrame=thisFrame,grassMaterial.uniforms.time.value=time,renderer.clear(),renderer.render(backgroundScene,camera),renderer.render(scene,camera),requestAnimationFrame(draw)}import*as THREE from"https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.module.min.js";var canvas=document.getElementById("canvas_1");const mobile=window.matchMedia("(max-width: 768px)").matches;var joints=4,bladeWidth=.12,bladeHeight=1,width=215,resolution=64,delta=width/resolution,speed=.5,pos=new THREE.Vector2(.01,.01),instances=mobile?5e4:15e4,loader=new THREE.TextureLoader;loader.crossOrigin="";var elevation,azimuth,moonTexture=loader.load("/assets/images/moon.webp"),now=new Date,hour=now.getHours();azimuth=.1,elevation=.1;var texture=hour<=6||hour>=20?moonTexture:null,position=new THREE.Vector3(Math.sin(azimuth)*Math.sin(azimuth),1*Math.sin(elevation),-Math.cos(azimuth)*Math.cos(azimuth)),sunMoonMaterial=(position=new THREE.Vector3(210,230,-2e3),new THREE.MeshBasicMaterial({map:null,side:THREE.DoubleSide}));sunMoonMaterial.map=texture,sunMoonMaterial.needsUpdate=!0;var fogFade=.005,ambientStrength=.3;ambientStrength=hour<=6||hour>=20?0:hour<=12?Math.min(Math.max(.1,(hour-7)/6),1):Math.min(Math.max(.1,1-(hour-12)/8),1);var translucencyStrength=.8,specularStrength=.5,diffuseStrength=.5,shininess=256,sunColour=new THREE.Vector3(ambientStrength,ambientStrength,ambientStrength),specularColour=new THREE.Vector3(.4,.4,.4),skyColour=new THREE.Color(ambientStrength,ambientStrength,ambientStrength);skyColour.multiplyScalar(ambientStrength);var scene=new THREE.Scene,backgroundScene=new THREE.Scene,renderer=new THREE.WebGLRenderer({antialias:!0,canvas:canvas}),defaultPixelRatio=renderer.getPixelRatio();renderer.outputEncoding=THREE.sRGBEncoding,renderer.setPixelRatio(window.devicePixelRatio),renderer.setSize(canvas.clientWidth,canvas.clientHeight,!1);var distance=1500,FOV=80,camera=new THREE.PerspectiveCamera(FOV,canvas.clientWidth/canvas.clientHeight,1,2e4);setCameraPosition(camera,0,7,60),scene.add(camera),backgroundScene.add(camera);var ambientLight=new THREE.AmbientLight(skyColour,.5);scene.add(ambientLight);var sunMoonGeometry=new THREE.CircleGeometry(100,32),sunMoon=new THREE.Mesh(sunMoonGeometry,sunMoonMaterial);sunMoon.lookAt(camera.position),sunMoon.position.copy(position),(hour<=6||hour>=20)&&scene.add(sunMoon),window.addEventListener("resize",onWindowResize,!1);var grassTexture=loader.load("/assets/images/blade_diffuse.webp"),alphaMap=loader.load("/assets/images/blade_alpha.webp"),noiseTexture=loader.load("/assets/images/perlin_noise.webp");noiseTexture.wrapS=THREE.RepeatWrapping,noiseTexture.wrapT=THREE.RepeatWrapping;const backgroundMaterial=new THREE.ShaderMaterial({uniforms:{ambientStrength:{type:"float",value:ambientStrength},sunDirection:{type:"vec3",value:new THREE.Vector3(Math.sin(azimuth),Math.sin(elevation),-Math.cos(azimuth))},resolution:{type:"vec2",value:new THREE.Vector2(canvas.width,canvas.height)},fogFade:{type:"float",value:fogFade},fov:{type:"float",value:FOV}},vertexShader:"\n    varying vec2 vUv;\n    void main() {\n      gl_Position = vec4( position, 1.0 );    \n    }\n  ",fragmentShader:"\n    varying vec2 vUv;\n    uniform vec2 resolution;\n    uniform float ambientStrength;\n    uniform vec3 sunDirection;\n    uniform float fogFade;\n    uniform float fov;\n\n    const vec3 baseSkyColour = vec3(0.09, 0.33, 0.81);\n\n    vec3 getSkyColour(vec3 rayDir){\n      vec3 skyColour = ambientStrength * baseSkyColour;\n      return mix(0.35*skyColour, skyColour, pow(1.0-rayDir.y, 4.0));\n    }\n    \n    //https://iquilezles.org/www/articles/fog/fog.htm\n    vec3 applyFog(vec3 rgb, vec3 rayOri, vec3 rayDir, vec3 sunDir){\n      //Make horizon more hazy\n      float dist = 4000.0;\n      if(abs(rayDir.y) < 0.0001){rayDir.y = 0.0001;}\n      float fogAmount = 1.0 * exp(-rayOri.y*fogFade) * (1.0-exp(-dist*rayDir.y*fogFade))/rayDir.y;\n      float sunAmount = max( dot( rayDir, sunDir ), 0.0 );\n      vec3 fogColor  = mix(vec3(0.35, 0.5, 0.9), vec3(1.0, 1.0, 0.75), pow(sunAmount, 16.0) );\n      return mix(rgb, fogColor, clamp(fogAmount, 0.0, 1.0));\n    }\n    \n    vec3 ACESFilm(vec3 x){\n      float a = 2.51;\n      float b = 0.03;\n      float c = 2.43;\n      float d = 0.59;\n      float e = 0.14;\n      return clamp((x*(a*x+b))/(x*(c*x+d)+e), 0.0, 1.0);\n    }\n    \n    vec3 rayDirection(float fieldOfView, vec2 fragCoord) {\n      vec2 xy = fragCoord - resolution.xy / 2.0;\n      float z = (0.5 * resolution.y) / tan(radians(fieldOfView) / 2.0);\n      return normalize(vec3(xy, -z));\n    }\n    \n    //https://www.geertarien.com/blog/2017/07/30/breakdown-of-the-lookAt-function-in-OpenGL/\n    mat3 lookAt(vec3 camera, vec3 at, vec3 up){\n      vec3 zaxis = normalize(at-camera);    \n      vec3 xaxis = normalize(cross(zaxis, up));\n      vec3 yaxis = cross(xaxis, zaxis);\n    \n      return mat3(xaxis, yaxis, -zaxis);\n    }\n    \n    float getGlow(float dist, float radius, float intensity){\n      dist = max(dist, 1e-6);\n      return pow(radius/dist, intensity);\t\n    }\n    \n    void main() {\n    \n      vec3 target = vec3(0.0, 0.0, 0.0);\n      vec3 up = vec3(0.0, 1.0, 0.0);\n      vec3 rayDir = rayDirection(fov, gl_FragCoord.xy);\n    \n      //Get the view matrix from the camera orientation\n      mat3 viewMatrix_ = lookAt(cameraPosition, target, up);\n    \n      //Transform the ray to point in the correct direction\n      rayDir = viewMatrix_ * rayDir;\n    \n      vec3 col = getSkyColour(rayDir);\n    \n      //Draw sun\n      vec3 sunDir = normalize(sunDirection);\n      float mu = dot(sunDir, rayDir);\n      col += vec3(1.0, 1.0, 0.8) * getGlow(1.0-mu, 0.00005, 0.9);\n    \n      col += applyFog(col, vec3(0,1000,0), rayDir, sunDir);\n    \n      //Tonemapping\n      col = ACESFilm(col);\n    \n      //Gamma correction 1.0/2.2 = 0.4545...\n      col = pow(col, vec3(0.4545));\n    \n      gl_FragColor = vec4(col, 1.0 );\n    }\n   "});backgroundMaterial.depthWrite=!1;var backgroundGeometry=new THREE.PlaneGeometry(2,2,1,1),background=new THREE.Mesh(backgroundGeometry,backgroundMaterial);backgroundScene.add(background),renderer.autoClear=!1;var groundBaseGeometry=new THREE.PlaneGeometry(width,width,resolution,resolution);groundBaseGeometry.lookAt(new THREE.Vector3(0,1,0)),groundBaseGeometry.verticesNeedUpdate=!0;var groundGeometry=new THREE.PlaneGeometry(width,width,resolution,resolution);groundGeometry.setAttribute("basePosition",groundBaseGeometry.getAttribute("position")),groundGeometry.lookAt(new THREE.Vector3(0,1,0)),groundGeometry.verticesNeedUpdate=!0;var groundShader,groundMaterial=new THREE.MeshPhongMaterial({color:new THREE.Color("rgb(15%, 35%, 4%)"),emissive:new THREE.Color("rgb(2%, 6%, 1%)")}),sharedPrefix="\n  uniform sampler2D noiseTexture;\n  float getYPosition(vec2 p){\n    return 15.0*(2.0*texture2D(noiseTexture, p/800.0).r - 1.0);\n  }\n",groundVertexPrefix=sharedPrefix+" \n  attribute vec3 basePosition;\n  uniform float delta;\n  uniform float posX;\n  uniform float posZ;\n  uniform float width;\n  \n  vec3 getPosition(vec3 pos, float epsX, float epsZ){\n    vec3 temp;\n    temp.x = pos.x + epsX;\n    temp.z = pos.z + epsZ;\n    temp.y = getYPosition(vec2(basePosition.x+epsX+delta*floor(posX), basePosition.z+epsZ+delta*floor(posZ)));\n    return temp;\n  }\n  \n  //Find the normal at pos as the cross product of the central-differences in x and z directions\n  vec3 getNormal(vec3 pos){\n    float eps = 1e-1;\n  \n    vec3 tempP = getPosition(pos, eps, 0.0);\n    vec3 tempN = getPosition(pos, -eps, 0.0);\n  \n    vec3 slopeX = tempP - tempN;\n  \n    tempP = getPosition(pos, 0.0, eps);\n    tempN = getPosition(pos, 0.0, -eps);\n  \n    vec3 slopeZ = tempP - tempN;\n  \n    vec3 norm = normalize(cross(slopeZ, slopeX));\n    return norm;\n  }\n";groundMaterial.onBeforeCompile=function(e){e.uniforms.delta={value:delta},e.uniforms.posX={value:pos.x},e.uniforms.posZ={value:pos.y},e.uniforms.width={value:width},e.uniforms.noiseTexture={value:noiseTexture},e.vertexShader=groundVertexPrefix+e.vertexShader,e.vertexShader=e.vertexShader.replace("#include <beginnormal_vertex>","//https://dev.to/maurobringolf/a-neat-trick-to-compute-modulo-of-negative-numbers-111e\n      vec3 pos = vec3(0);\n      pos.x = basePosition.x - mod(mod((delta*posX),delta) + delta, delta);\n      pos.z = basePosition.z - mod(mod((delta*posZ),delta) + delta, delta);\n      pos.y = getYPosition(vec2(basePosition.x+delta*floor(posX), basePosition.z+delta*floor(posZ)));\n      vec3 objectNormal = getNormal(pos);\n#ifdef USE_TANGENT\n      vec3 objectTangent = vec3( tangent.xyz );\n#endif"),e.vertexShader=e.vertexShader.replace("#include <begin_vertex>","vec3 transformed = vec3(pos);"),groundShader=e};var ground=new THREE.Mesh(groundGeometry,groundMaterial);ground.geometry.computeVertexNormals(),scene.add(ground);var grassVertexSource=sharedPrefix+"\n  precision mediump float;\n  attribute vec3 position;\n  attribute vec3 normal;\n  attribute vec3 offset;\n  attribute vec2 uv;\n  attribute vec2 halfRootAngle;\n  attribute float scale;\n  attribute float index;\n  uniform float time;\n  \n  uniform float delta;\n  uniform float posX;\n  uniform float posZ;\n  uniform float width;\n  \n  uniform mat4 modelViewMatrix;\n  uniform mat4 projectionMatrix;\n  \n  varying vec2 vUv;\n  varying vec3 vNormal;\n  varying vec3 vPosition;\n  varying float frc;\n  varying float idx;\n\n  const float PI = 3.1415;\n  const float TWO_PI = 2.0 * PI;\n  \n  //https://www.geeks3d.com/20141201/how-to-rotate-a-vertex-by-a-quaternion-in-glsl/\n  vec3 rotateVectorByQuaternion(vec3 v, vec4 q){\n    return 2.0 * cross(q.xyz, v * q.w + cross(q.xyz, v)) + v;\n  }\n  \n  void main() {\n  \n    //Vertex height in blade geometry\n    frc = position.y / float("+bladeHeight+");\n  \n    //Scale vertices\n    vec3 vPosition = position;\n    vPosition.y *= scale;\n  \n    //Invert scaling for normals\n    vNormal = normal;\n    vNormal.y /= scale;\n  \n    //Rotate blade around Y axis\n    vec4 direction = vec4(0.0, halfRootAngle.x, 0.0, halfRootAngle.y);\n    vPosition = rotateVectorByQuaternion(vPosition, direction);\n    vNormal = rotateVectorByQuaternion(vNormal, direction);\n  \n    //UV for texture\n    vUv = uv;\n  \n    vec3 pos;\n    vec3 globalPos;\n    vec3 tile;\n  \n    globalPos.x = offset.x-posX*delta;\n    globalPos.z = offset.z-posZ*delta;\n  \n    tile.x = floor((globalPos.x + 0.5 * width) / width);\n    tile.z = floor((globalPos.z + 0.5 * width) / width);\n  \n    pos.x = globalPos.x - tile.x * width;\n    pos.z = globalPos.z - tile.z * width;\n  \n    pos.y = getYPosition(vec2(pos.x+delta*posX, pos.z+delta*posZ));\n  \n    //Position of the blade in the visible patch [0->1]\n    vec2 fractionalPos = 0.5 + offset.xz / width;\n    //To make it seamless, make it a multiple of 2*PI\n    fractionalPos *= TWO_PI;\n\n    //Wind is sine waves in time. \n    float noise = 0.5 + 0.5 * sin(fractionalPos.x + time);\n    float halfAngle = -noise * 0.1;\n    noise = 0.5 + 0.5 * cos(fractionalPos.y + time);\n    halfAngle -= noise * 0.05;\n  \n    direction = normalize(vec4(sin(halfAngle), 0.0, -sin(halfAngle), cos(halfAngle)));\n  \n    //Rotate blade and normals according to the wind\n    vPosition = rotateVectorByQuaternion(vPosition, direction);\n    vNormal = rotateVectorByQuaternion(vNormal, direction);\n  \n    //Move vertex to global location\n    vPosition += pos;\n  \n    //Index of instance for varying colour in fragment shader\n    idx = index;\n  \n    gl_Position = projectionMatrix * modelViewMatrix * vec4(vPosition, 1.0);\n  }  \n",grassFragmentSource="\n  precision mediump float;\n  \n  uniform vec3 cameraPosition;\n  \n  //Light uniforms\n  uniform float ambientStrength;\n  uniform float diffuseStrength;\n  uniform float specularStrength;\n  uniform float translucencyStrength;\n  uniform float shininess;\n  uniform vec3 lightColour;\n  uniform vec3 sunDirection;\n  \n  \n  //Surface uniforms\n  uniform sampler2D map;\n  uniform sampler2D alphaMap;\n  uniform vec3 specularColour;\n  \n  varying float frc;\n  varying float idx;\n  varying vec2 vUv;\n  varying vec3 vNormal;\n  varying vec3 vPosition;\n  \n  vec3 ACESFilm(vec3 x){\n    float a = 2.51;\n    float b = 0.03;\n    float c = 2.43;\n    float d = 0.59;\n    float e = 0.14;\n    return clamp((x*(a*x+b))/(x*(c*x+d)+e), 0.0, 1.0);\n  }\n  \n  void main() {\n  \n    //If transparent, don't draw\n    if(texture2D(alphaMap, vUv).r < 0.15){\n      discard;\n    }\n  \n    vec3 normal;\n  \n    //Flip normals when viewing reverse of the blade\n    if(gl_FrontFacing){\n      normal = normalize(vNormal);\n    }else{\n      normal = normalize(-vNormal);\n    }\n  \n    //Get colour data from texture\n    vec3 textureColour = pow(texture2D(map, vUv).rgb, vec3(2.2));\n  \n    //Add different green tones towards root\n    vec3 mixColour = idx > 0.75 ? vec3(0.2, 0.8, 0.06) : vec3(0.5, 0.8, 0.08);\n    textureColour = mix(0.1 * mixColour, textureColour, 0.75);\n  \n    vec3 lightTimesTexture = lightColour * textureColour;\n    vec3 ambient = textureColour;\n    vec3 lightDir = normalize(sunDirection);\n  \n    //How much a fragment faces the light\n    float dotNormalLight = dot(normal, lightDir);\n    float diff = max(dotNormalLight, 0.0);\n  \n    //Colour when lit by light\n    vec3 diffuse = diff * lightTimesTexture;\n  \n    float sky = max(dot(normal, vec3(0,1,0)), 0.0);\n    vec3 skyLight = sky * vec3(0.12, 0.29, 0.55);\n  \n    vec3 viewDirection = normalize(cameraPosition - vPosition);\n    vec3 halfwayDir = normalize(lightDir + viewDirection);\n    //How much a fragment directly reflects the light to the camera\n    float spec = pow(max(dot(normal, halfwayDir), 0.0), shininess);\n  \n    //Colour of light sharply reflected into the camera\n    vec3 specular = spec * specularColour * lightColour;\n  \n    //https://en.wikibooks.org/wiki/GLSL_Programming/Unity/Translucent_Surfaces\n    vec3 diffuseTranslucency = vec3(0);\n    vec3 forwardTranslucency = vec3(0);\n    float dotViewLight = dot(-lightDir, viewDirection);\n    if(dotNormalLight <= 0.0){\n      diffuseTranslucency = lightTimesTexture * translucencyStrength * -dotNormalLight;\n      if(dotViewLight > 0.0){\n        forwardTranslucency = lightTimesTexture * translucencyStrength * pow(dotViewLight, 16.0);\n      }\n    }\n  \n    vec3 col = 0.3 * skyLight * textureColour + ambientStrength * ambient + diffuseStrength * diffuse + specularStrength * specular + diffuseTranslucency + forwardTranslucency;\n  \n    //Add a shadow towards root\n    col = mix(0.35*vec3(0.1, 0.25, 0.02), col, frc);\n    \n    //Tonemapping\n    col = ACESFilm(col);\n  \n    //Gamma correction 1.0/2.2 = 0.4545...\n    col = pow(col, vec3(0.4545));\n  \n    gl_FragColor = vec4(col, 1.0);\n  }\n",grassBaseGeometry=new THREE.PlaneGeometry(bladeWidth,bladeHeight,1,joints);grassBaseGeometry.translate(0,bladeHeight/2,0);let x,y,z,w,angle,sinAngle,rotationAngle,vertex=new THREE.Vector3,quaternion0=new THREE.Quaternion,quaternion1=new THREE.Quaternion;setQuaternion(quaternion0,new THREE.Vector3(0,1,0),.05),setQuaternion(quaternion1,new THREE.Vector3(1,0,0),.3),quaternion0.multiply(quaternion1),setQuaternion(quaternion1,new THREE.Vector3(0,0,1),.1),quaternion0.multiply(quaternion1);let quaternion2=new THREE.Quaternion;for(let e=0;e<grassBaseGeometry.attributes.position.array.length;e+=3){quaternion2.setFromAxisAngle(new THREE.Vector3(0,1,0),Math.PI/2),vertex.x=grassBaseGeometry.attributes.position.array[e],vertex.y=grassBaseGeometry.attributes.position.array[e+1],vertex.z=grassBaseGeometry.attributes.position.array[e+2];let n=vertex.y/bladeHeight;quaternion2.slerp(quaternion0,n),vertex.applyQuaternion(quaternion2),grassBaseGeometry.attributes.position.array[e]=vertex.x,grassBaseGeometry.attributes.position.array[e+1]=vertex.y,grassBaseGeometry.attributes.position.array[e+2]=vertex.z}grassBaseGeometry.computeVertexNormals();var baseMaterial=new THREE.MeshNormalMaterial({side:THREE.DoubleSide}),baseBlade=new THREE.Mesh(grassBaseGeometry,baseMaterial),instancedGeometry=new THREE.InstancedBufferGeometry;instancedGeometry.index=grassBaseGeometry.index,instancedGeometry.attributes.position=grassBaseGeometry.attributes.position,instancedGeometry.attributes.uv=grassBaseGeometry.attributes.uv,instancedGeometry.attributes.normal=grassBaseGeometry.attributes.normal;let indices=Array.from({length:instances},(e,n)=>n/instances),offsets=[],scales=[],halfRootAngles=[];for(let e=0;e<instances;e++){offsets.push(Math.random()*width-width/2,0,Math.random()*width-width/2);let n=Math.PI-Math.random()*(2*Math.PI);halfRootAngles.push(Math.sin(.5*n),Math.cos(.5*n)),scales.push(2+Math.random()*(e%3!=0?1.25:1))}var offsetAttribute=new THREE.InstancedBufferAttribute(new Float32Array(offsets),3),scaleAttribute=new THREE.InstancedBufferAttribute(new Float32Array(scales),1),halfRootAngleAttribute=new THREE.InstancedBufferAttribute(new Float32Array(halfRootAngles),2),indexAttribute=new THREE.InstancedBufferAttribute(new Float32Array(indices),1);instancedGeometry.setAttribute("offset",offsetAttribute),instancedGeometry.setAttribute("scale",scaleAttribute),instancedGeometry.setAttribute("halfRootAngle",halfRootAngleAttribute),instancedGeometry.setAttribute("index",indexAttribute);var grassMaterial=new THREE.RawShaderMaterial({uniforms:{time:{type:"float",value:0},delta:{type:"float",value:delta},posX:{type:"float",value:pos.x},posZ:{type:"float",value:pos.y},width:{type:"float",value:width},map:{value:grassTexture},alphaMap:{value:alphaMap},noiseTexture:{value:noiseTexture},sunDirection:{type:"vec3",value:new THREE.Vector3(Math.sin(azimuth),Math.sin(elevation),-Math.cos(azimuth))},cameraPosition:{type:"vec3",value:camera.position},ambientStrength:{type:"float",value:ambientStrength},translucencyStrength:{type:"float",value:translucencyStrength},diffuseStrength:{type:"float",value:diffuseStrength},specularStrength:{type:"float",value:specularStrength},shininess:{type:"float",value:shininess},lightColour:{type:"vec3",value:sunColour},specularColour:{type:"vec3",value:specularColour}},vertexShader:grassVertexSource,fragmentShader:grassFragmentSource,side:THREE.DoubleSide}),grass=new THREE.Mesh(instancedGeometry,grassMaterial);scene.add(grass);var thisFrame,viewDirection=new THREE.Vector3,upVector=new THREE.Vector3(0,1,0),time=0,lastFrame=Date.now();draw();